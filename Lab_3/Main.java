// В классическом наборе домино 28 костей. Кости представляют собой прямоугольники,
// разделенные на 2 части, на каждой из них отмечены точки от 0 до 6. Каждая кость уникальна.
// Напишите программу, используя объектно-ориентированную методологию, которая создает объект
// набор домино, а затем выводит его на экран (пара целых чисел). Далее набор преобразуется в
// последовательность (для каждой кости хранится местоположение следующей за ней). Для этого из
// набора случайным образом выбирается кость и добавляется в конец последовательности
// (исходно последовательность пустая). Для того чтобы не проходить через всю
// последовательность, при добавлении очередной кости, необходимо хранить местоположения
// последней добавленной кости, для которой, в свою очередь, хранится местоположение первой.
// После того как последовательность из 28 костей полностью сформирована, она выводится на
// экран от первой кости последовательности до последней. Далее необходимо по заданному числу
// N (задается в main()) последовательно исключить сначала кость N от начала последовательности,
// потом кость N от следующей после исключенной и так далее пока из последовательности не будут
// исключены все кости. При этом каждый раз на экран необходимо выводить на одной строке
// исключенную на данном шаге кость, на следующей оставшуюся после очередного исключения
// последовательность от ее первой кости до последней. Если при очередном поиске исключаемой
// кости дошли до конца последовательности, то поиск необходимо продолжить от начала
// последовательности. Используйте для хранения набора и последовательности костей только один
// массив из 28 элементов. При поиске кости и выводе на экран последовательности не должно быть
// посещений исключенных из последовательности костей!

public class Main {
    public static void main(String[] args){
        StartBox a = new StartBox(); // создали набор
        a.print(); // вывели набор
        System.out.println();
        Sequence b = new Sequence(a.returnDomino()); // создали последовательность, основываясь на массиве из набора
        a.toSequence(b); // заполнили последовательность
        b.print(); // вывели последовательность
        int step = 30; // задали то, каждый какой элемент мы хотим удалять
        System.out.println();
        deleteAll(b, step); // удаляем каждый step-ный элемент с выводом всего на экран
    }

    // метод удаляет каждый step-ный элемент последовательности, пока не кончатся элементы
    public static void deleteAll(Sequence X, int step){
        // последовательность X, чтобы удалять из неё элементы, step - шаг удаления
        int counter; // счётчик того, сколько элементов мы уже удалили
        int position = X.getStartPosition(); // position отвечает за элемент, в котором мы стоим, изначально он равен концу последовательности
        Domino fordelete; // переменная, куда в которую мы будем возвращать удаляемую доминошку
        for (counter = 0; counter < 28; counter++){ // пока counter < 28 нам есть что удалять
            fordelete = X.delete(position, (step - 1) % (28 - counter)); // удаляем элемент и возвращаем его для вывода
            // нужно передать позицию, в которой мы стоим и какой сделать шаг
            // мы берём остаток от деления на (28 - counter), потому что это длина нашей последовательности
            // и нет никакого смысла ходить по ней лишние круги
            fordelete.print(); // выводим удаляемый элемент
            position = fordelete.getLink(); // достаём из удалённого элемента новую позицию, с которой начнём в следующий раз
            System.out.println();
            X.print(); // выводим обновлённую последовательность
            System.out.println();
        }
    }
}